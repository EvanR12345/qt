<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Choice Title. (Instant Feedback)</title>
  <style>
    :root {
      --bg:#fff;
      --text:#111;
      --muted:#666;
      --border:#ddd;
      --surface:#fff;
      --surface-soft:#fafafa;
      --ok:#0a7a2f;
      --bad:#b00020;
      --button-bg:#f7f7f7;
      --button-hover:#efefef;
      --accent:#5b5cf0;
      --accent-soft:rgba(91,92,240,.15);
    }
    html,body{background:var(--bg); color:var(--text); margin:0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;}
    .wrap{max-width:980px; margin:28px auto; padding:0 16px 40px;}
    h1{font-size:22px; margin:0 0 8px;}
    .sub{color:var(--muted); margin:0 0 18px; line-height:1.4;}
    .toolbar{display:flex; flex-wrap:wrap; gap:10px; align-items:center; padding:12px; border:1px solid var(--border); border-radius:12px; margin:16px 0 18px;}
    .toolbar > *{margin:0;}
    button{cursor:pointer; border:1px solid var(--border); background:var(--button-bg); color:var(--text); padding:10px 12px; border-radius:10px; font-weight:700; box-shadow:none; transition:.18s ease;}
    button:hover{background:var(--button-hover); transform:none; box-shadow:none;}
    body.fancy-ui button{border:1px solid color-mix(in srgb, var(--accent) 20%, var(--border)); background:linear-gradient(145deg, color-mix(in srgb, var(--accent) 10%, var(--button-bg)), var(--button-bg)); box-shadow:0 6px 14px rgba(0,0,0,.08);}
    body.fancy-ui button:hover{background:linear-gradient(145deg, color-mix(in srgb, var(--accent) 14%, var(--button-hover)), var(--button-hover)); transform:translateY(-1px); box-shadow:0 10px 16px rgba(0,0,0,.12);}
    .pill{padding:8px 10px; border:1px solid var(--border); border-radius:999px; background:var(--surface-soft); font-size:13px;}
    .q{border:1px solid var(--border); border-radius:14px; padding:14px 14px 10px; margin:12px 0; background:var(--surface);}
    .qhead{display:flex; gap:10px; align-items:flex-start; justify-content:space-between;}
    .qtitle{font-weight:800; font-size:14px; margin:0;}
    .tag{font-size:12px; color:var(--muted); border:1px solid var(--border); padding:4px 8px; border-radius:999px; white-space:nowrap;}
    .prompt{margin:10px 0 12px; line-height:1.4;}
    .opts{display:grid; gap:8px; margin:0 0 10px;}
    label.opt{display:flex; gap:10px; align-items:flex-start; border:1px solid var(--border); border-radius:12px; padding:10px; cursor:pointer; background:var(--surface); transition:.18s ease;}
    label.opt:hover{background:var(--surface-soft);}
    body.fancy-ui label.opt{border:1px solid color-mix(in srgb, var(--accent) 26%, var(--border)); background:linear-gradient(145deg, color-mix(in srgb, var(--accent) 7%, var(--surface)), var(--surface)); box-shadow:0 4px 12px rgba(0,0,0,.08);}
    body.fancy-ui label.opt:hover{background:linear-gradient(145deg, color-mix(in srgb, var(--accent) 12%, var(--surface-soft)), var(--surface-soft)); transform:translateY(-1px);}
    input[type="radio"]{margin-top:2px;}
    .feedback{margin:10px 0 6px; padding:10px 12px; border-radius:12px; border:1px solid var(--border); background:var(--surface-soft); display:none;}
    .question-actions{display:flex; justify-content:flex-end; margin:4px 0 8px;}
    .check-btn{padding:8px 10px; font-size:13px;}
    .feedback.ok{border-color:rgba(10,122,47,.35); background:rgba(10,122,47,.08); color:var(--ok);}
    .feedback.bad{border-color:rgba(176,0,32,.35); background:rgba(176,0,32,.08); color:var(--bad);}
    .explain{color:var(--text); margin-top:6px; font-size:13px; line-height:1.35;}
    .explain .muted{color:var(--muted);}
    .small{font-size:12px; color:var(--muted);}
    .status-ok{color:var(--ok);}    
    .status-error{color:var(--bad);}    
    .kbd{font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
         font-size:12px; padding:2px 6px; border:1px solid var(--border); border-radius:6px; background:var(--surface);}
    .scorebar{display:flex; gap:10px; align-items:center; flex-wrap:wrap;}
    progress{width:220px; height:12px;}
    .divider{height:1px; background:var(--border); margin:10px 0;}
    .note{font-size:13px; color:var(--muted); margin-top:8px;}
    .settings-panel{display:none; margin:0 0 16px; padding:12px; border:1px solid var(--border); border-radius:12px; background:var(--surface-soft);}
    .settings-panel.open{display:block;}
    .settings-title{font-weight:700; margin:0 0 10px;}
    .setting{display:flex; align-items:center; gap:8px; margin:8px 0; font-size:14px;}
    .setting.column{align-items:flex-start; flex-direction:column; gap:6px;}
    .setting.column span{font-weight:600;}
    .setting.column input[type="color"]{width:56px; height:32px; border:1px solid var(--border); border-radius:8px; padding:2px; background:var(--surface);}
    .setting.column input[type="text"]{width:min(520px,100%); border:1px solid var(--border); border-radius:8px; padding:8px 10px; background:var(--surface); color:var(--text); box-sizing:border-box;}
    .title-row{display:flex; gap:10px; align-items:center; width:min(760px,100%); flex-wrap:wrap;}
    .title-row input[type="text"]{flex:1 1 360px; min-width:220px;}
    .title-row select{flex:1 1 220px; min-width:200px; border:1px solid var(--border); border-radius:10px; padding:9px 10px; background:var(--surface); color:var(--text); font-weight:600; box-shadow:inset 0 0 0 1px var(--accent-soft);}
    .settings-panel textarea{width:100%; min-height:150px; resize:vertical; border:1px solid var(--border); border-radius:10px; padding:10px; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace; font-size:12px; box-sizing:border-box;}
    .settings-actions{display:flex; gap:8px; align-items:center; margin-top:8px; flex-wrap:wrap;}
    #clipboardPromptPreview{display:none; min-height:120px; margin-top:8px;}
    .compact .q{padding:10px 10px 8px; margin:8px 0;}
    .compact .prompt{margin:6px 0 8px;}
    .compact .opts{gap:6px;}
  </style>
</head>
<body>
  <div class="wrap">
    <h1 id="quizTitle">Choice Title.</h1>
    <p class="sub">
      This is a foramt for future pratice questions<br>
      <span id="instantFeedbackHint" class="small">Instant feedback • custom background • Click an option to answer.</span>
    </p>

    <div class="toolbar">
      <div class="scorebar">
        <span class="pill"><strong>Score:</strong> <span id="score">0</span>/<span id="total">0</span></span>
        <span class="pill"><strong>Answered:</strong> <span id="answered">0</span>/<span id="total2">0</span></span>
        <progress id="prog" value="0" max="1"></progress>
      </div>
      <button id="shuffleBtn" type="button">Shuffle Questions</button>
      <button id="resetBtn" type="button">Reset Answers</button>
      <button id="settingsBtn" type="button" aria-expanded="false" aria-controls="settingsPanel">Settings</button>
      <span class="pill">Tip: press <span class="kbd">Ctrl</span> + <span class="kbd">F</span> to find keywords</span>
    </div>

    <div id="settingsPanel" class="settings-panel" aria-live="polite">
      <p class="settings-title">Quiz Settings</p>
      <label class="setting">
        <input id="showExplanationsToggle" type="checkbox" checked />
        Show explanations after answering
      </label>
      <label class="setting">
        <input id="shuffleOnResetToggle" type="checkbox" />
        Shuffle questions when resetting answers
      </label>
      <label class="setting">
        <input id="compactModeToggle" type="checkbox" />
        Use compact question cards
      </label>
      <label class="setting">
        <input id="shuffleOptionsToggle" type="checkbox" />
        Swap/shuffle answer options for each question
      </label>
      <label class="setting column">
        <span>Quiz title</span>
        <div class="title-row">
          <input id="titleInput" type="text" value="Choice Title." />
          <select id="titleStyleSelect" aria-label="Title style preset">
            <option value="classic">Classic Clean</option>
            <option value="exam">Exam Prep</option>
            <option value="flash">Flash Cards</option>
            <option value="brain">Brain Boost</option>
            <option value="neon">Neon Study Night</option>
            <option value="ocean">Ocean Calm</option>
            <option value="forest">Forest Focus</option>
            <option value="sunset">Sunset Energy</option>
            <option value="royal">Royal Purple</option>
            <option value="mono">Monochrome Pro</option>
          </select>
        </div>
      </label>
      <label class="setting">
        <input id="instantFeedbackToggle" type="checkbox" checked />
        Enable Instant Feedback
      </label>
      <label class="setting">
        <input id="fancyButtonsToggle" type="checkbox" />
        Fancy buttons + option cards
      </label>

      <p class="settings-title" style="margin-top:12px;">Colour Theme</p>
      <label class="setting column">
        <span>Page background</span>
        <input id="bgColorInput" type="color" value="#ffffff" />
      </label>
      <label class="setting column">
        <span>Cards + controls tint</span>
        <input id="surfaceTintInput" type="color" value="#fafafa" />
      </label>
      <label class="setting">
        <input id="nightModeToggle" type="checkbox" />
        Enable Night mode
      </label>
      <div class="settings-actions">
        <button id="resetColorsBtn" type="button">Reset Colours</button>
        <button id="restoreDefaultColorsBtn" type="button">Restore Default Colours</button>
        <button id="clearSavedDataBtn" type="button">Clear Saved Data</button>
      </div>

      <div class="settings-actions" style="margin-top:12px;">
        <button id="toggleHtmlSectionBtn" type="button" aria-expanded="true" aria-controls="loadQuestionsSection">Hide Load Questions from HTML</button>
      </div>
      <div id="loadQuestionsSection">
        <p class="settings-title" style="margin-top:12px;">Load Questions from HTML</p>
        <textarea id="questionsHtmlInput" placeholder="Paste HTML using this format:">
<article data-question data-topic="math" data-answer="0" data-explain="Because 3 + 2 equals 5.">
  <h3>What is 3 + 2?</h3>
  <ul>
    <li>5</li>
    <li>6</li>
    <li>4</li>
    <li>7</li>
  </ul>
</article>
<article data-question data-topic="math" data-answer="2" data-explain="Because 7 + 3 equals 10.">
  <h3>What is 7 + 3?</h3>
  <ul>
    <li>9</li>
    <li>11</li>
    <li>10</li>
    <li>8</li>
  </ul>
</article>
<article data-question data-topic="math" data-answer="1" data-explain="Because 9 + 4 equals 13.">
  <h3>What is 9 + 4?</h3>
  <ul>
    <li>12</li>
    <li>13</li>
    <li>14</li>
    <li>15</li>
  </ul>
</article>
</textarea>
        <div class="settings-actions">
          <button id="loadQuestionsHtmlBtn" type="button">Load HTML Questions</button>
          <button id="saveLoadedQuizBtn" type="button">Save Loaded Quiz</button>
          <button id="copyPromptBtn" type="button">Input prompt in chat</button>
          <span id="htmlLoadStatus" class="small"></span>
        </div>
        <label class="setting column">
          <span>Saved quiz title</span>
          <div class="title-row">
            <input id="saveQuizTitleInput" type="text" maxlength="80" placeholder="Example: Algebra Set 1" />
            <select id="savedQuizSelect" aria-label="Saved quizzes"></select>
          </div>
        </label>
        <div class="settings-actions">
          <button id="loadSavedQuizBtn" type="button">Load Saved Quiz</button>
          <button id="deleteSavedQuizBtn" type="button">Delete Saved Quiz</button>
        </div>

        <p class="settings-title" style="margin-top:12px;">Fix Answer Key</p>
        <label class="setting column">
          <span>Type a correction (example: question 34 is wrong it should be c)</span>
          <input id="answerFixInput" type="text" placeholder="question 34 is wrong it should be c" maxlength="120" autocomplete="off" autocapitalize="off" spellcheck="false" />
        </label>
        <div class="settings-actions">
          <button id="applyAnswerFixBtn" type="button">Apply Answer Fix</button>
          <span id="answerFixStatus" class="small"></span>
        </div>

        <textarea id="clipboardPromptPreview" readonly aria-label="Clipboard prompt manual copy text"></textarea>
      </div>
    </div>

    <div id="quiz"></div>
    <p class="note">Any ideas to make it better is appreciated!</p>
  </div>

  <script>
    const DEFAULT_QUESTIONS = [
      {
        topic: "math",
        q: "What is 3 + 2?",
        choices: ["5", "6", "4", "7"],
        answer: 0,
        explain: "Because 3 + 2 equals 5."
      },
      {
        topic: "math",
        q: "What is 7 + 3?",
        choices: ["9", "11", "10", "8"],
        answer: 2,
        explain: "Because 7 + 3 equals 10."
      },
      {
        topic: "math",
        q: "What is 9 + 4?",
        choices: ["12", "13", "14", "15"],
        answer: 1,
        explain: "Because 9 + 4 equals 13."
      }
    ];

    let questionsBank = DEFAULT_QUESTIONS.map((q) => ({
      ...q,
      choices: [...q.choices]
    }));

    const DEFAULT_SETTINGS = {
      showExplanations: true,
      shuffleOnReset: false,
      compactMode: false,
      shuffleOptions: false,
      titleText: "Choice Title.",
      titleStyle: "classic",
      instantFeedbackEnabled: true,
      fancyButtons: false,
      nightMode: false,
      dayTheme: { bg: "#ffffff", surfaceTint: "#fafafa" },
      nightTheme: { bg: "#0f172a", surfaceTint: "#1e293b" }
    };

    let state = {
      order: [],
      answers: {},
      locked: {},
      score: 0,
      answered: 0,
      choiceOrder: {},
      settings: { ...DEFAULT_SETTINGS }
    };


    const MAX_HTML_INPUT_LENGTH = 100000;
    const MAX_QUESTIONS = 200;
    const MAX_CHOICES_PER_QUESTION = 20;
    const MAX_TEXT_LENGTH = 500;
    const MAX_ANSWER_FIX_INPUT_LENGTH = 120;
    const FORBIDDEN_TAGS = new Set(["script", "iframe", "object", "embed", "link", "style", "meta", "base", "form"]);
    const FORBIDDEN_ATTR_PREFIXES = ["on"];
    const FORBIDDEN_ATTR_NAMES = new Set(["srcdoc"]);
    const DEFAULT_THEME = {
      bg: "#ffffff",
      surfaceTint: "#fafafa"
    };
    const NIGHT_THEME = {
      bg: "#0f172a",
      surfaceTint: "#1e293b"
    };
    const STORAGE_KEYS = {
      settings: "qt.quiz.settings.v1",
      questionsHtmlInput: "qt.quiz.questionsHtmlInput.v1",
      answerFixInput: "qt.quiz.answerFixInput.v1",
      questionsBank: "qt.quiz.questionsBank.v1",
      progress: "qt.quiz.progress.v1",
      savedQuizzes: "qt.quiz.savedQuizzes.v1"
    };

    const TITLE_STYLE_PRESETS = {
      classic: { accent: "#5b5cf0" },
      exam: { accent: "#2563eb" },
      flash: { accent: "#d946ef" },
      brain: { accent: "#f97316" },
      neon: { accent: "#06b6d4" },
      ocean: { accent: "#0ea5e9" },
      forest: { accent: "#16a34a" },
      sunset: { accent: "#ef4444" },
      royal: { accent: "#7c3aed" },
      mono: { accent: "#475569" }
    };

    function readStorageJson(key) {
      try {
        const raw = localStorage.getItem(key);
        if (!raw) return null;
        return JSON.parse(raw);
      } catch {
        return null;
      }
    }

    function writeStorageJson(key, value) {
      try {
        localStorage.setItem(key, JSON.stringify(value));
      } catch {
        // Ignore storage quota/privacy mode failures.
      }
    }

    function writeStorageText(key, value) {
      try {
        localStorage.setItem(key, String(value || ""));
      } catch {
        // Ignore storage quota/privacy mode failures.
      }
    }

    function isValidQuestionBank(candidate) {
      if (!Array.isArray(candidate) || !candidate.length || candidate.length > MAX_QUESTIONS) return false;
      return candidate.every((item) => {
        if (!item || typeof item !== "object") return false;
        if (!Array.isArray(item.choices) || item.choices.length < 2 || item.choices.length > MAX_CHOICES_PER_QUESTION) return false;
        if (!Number.isInteger(item.answer) || item.answer < 0 || item.answer >= item.choices.length) return false;
        return typeof item.topic === "string" && typeof item.q === "string" && typeof item.explain === "string";
      });
    }

    function saveSettings() {
      writeStorageJson(STORAGE_KEYS.settings, state.settings);
    }

    function saveQuestionsBank() {
      writeStorageJson(STORAGE_KEYS.questionsBank, questionsBank);
    }

    function isValidProgress(candidate) {
      if (!candidate || typeof candidate !== "object") return false;
      const { answers, locked, score, answered, order, choiceOrder } = candidate;
      if (!answers || typeof answers !== "object") return false;
      if (!locked || typeof locked !== "object") return false;
      if (!Number.isInteger(score) || score < 0) return false;
      if (!Number.isInteger(answered) || answered < 0) return false;
      if (!Array.isArray(order) || order.length !== questionsBank.length) return false;
      if (!choiceOrder || typeof choiceOrder !== "object") return false;

      const total = questionsBank.length;
      const inRange = (n) => Number.isInteger(n) && n >= 0 && n < total;
      if (!order.every(inRange)) return false;
      if (new Set(order).size !== total) return false;

      for (const [qidStr, choiceIdx] of Object.entries(answers)) {
        const qid = Number(qidStr);
        if (!inRange(qid)) return false;
        if (!Number.isInteger(choiceIdx) || choiceIdx < 0 || choiceIdx >= questionsBank[qid].choices.length) return false;
      }

      for (const qidStr of Object.keys(locked)) {
        const qid = Number(qidStr);
        if (!inRange(qid)) return false;
      }

      for (const [qidStr, arr] of Object.entries(choiceOrder)) {
        const qid = Number(qidStr);
        if (!inRange(qid) || !Array.isArray(arr) || arr.length !== questionsBank[qid].choices.length) return false;
        if (!arr.every((idx) => Number.isInteger(idx) && idx >= 0 && idx < questionsBank[qid].choices.length)) return false;
      }

      return true;
    }

    function saveProgress() {
      writeStorageJson(STORAGE_KEYS.progress, {
        answers: state.answers,
        locked: state.locked,
        score: state.score,
        answered: state.answered,
        order: state.order,
        choiceOrder: state.choiceOrder
      });
    }

    function hydrateFromStorage() {
      const storedSettings = readStorageJson(STORAGE_KEYS.settings);
      if (storedSettings && typeof storedSettings === "object") {
        state.settings = { ...state.settings, ...storedSettings };
      }
      state.settings.dayTheme = {
        bg: normalizeHexColor(state.settings.dayTheme?.bg, DEFAULT_THEME.bg),
        surfaceTint: normalizeHexColor(state.settings.dayTheme?.surfaceTint, DEFAULT_THEME.surfaceTint)
      };
      state.settings.nightTheme = {
        bg: normalizeHexColor(state.settings.nightTheme?.bg, NIGHT_THEME.bg),
        surfaceTint: normalizeHexColor(state.settings.nightTheme?.surfaceTint, NIGHT_THEME.surfaceTint)
      };

      const storedQuestionsBank = readStorageJson(STORAGE_KEYS.questionsBank);
      if (isValidQuestionBank(storedQuestionsBank)) {
        questionsBank = storedQuestionsBank.map((q) => ({
          topic: clampText(q.topic, 80),
          q: clampText(q.q),
          choices: q.choices.map((choice) => clampText(choice)).filter(Boolean),
          answer: q.answer,
          explain: clampText(q.explain)
        }));
      }

      const htmlDraft = localStorage.getItem(STORAGE_KEYS.questionsHtmlInput);
      if (typeof htmlDraft === "string") {
        document.getElementById("questionsHtmlInput").value = htmlDraft.slice(0, MAX_HTML_INPUT_LENGTH);
      }

      const answerFixDraft = localStorage.getItem(STORAGE_KEYS.answerFixInput);
      if (typeof answerFixDraft === "string") {
        document.getElementById("answerFixInput").value = answerFixDraft.slice(0, MAX_ANSWER_FIX_INPUT_LENGTH);
      }
    }

    function hydrateProgressFromStorage() {
      const storedProgress = readStorageJson(STORAGE_KEYS.progress);
      if (!isValidProgress(storedProgress)) return;
      state.answers = { ...storedProgress.answers };
      state.locked = { ...storedProgress.locked };
      state.score = storedProgress.score;
      state.answered = storedProgress.answered;
      state.order = [...storedProgress.order];
      state.choiceOrder = { ...storedProgress.choiceOrder };
    }

    function clearSavedData() {
      const ok = window.confirm("Confirm resetting all website data? This clears saved settings, drafts, custom questions, and progress.");
      if (!ok) return;

      Object.values(STORAGE_KEYS).forEach((key) => localStorage.removeItem(key));

      questionsBank = DEFAULT_QUESTIONS.map((q) => ({ ...q, choices: [...q.choices] }));
      state.settings = { ...DEFAULT_SETTINGS };
      state.answers = {};
      state.locked = {};
      state.score = 0;
      state.answered = 0;
      state.choiceOrder = {};

      initOrder();
      syncSettingsControls();
      document.getElementById("questionsHtmlInput").value = "";
      document.getElementById("answerFixInput").value = "";
      setStatus("Saved website data cleared.");
      setAnswerFixStatus("Saved answer-fix data cleared.");
      updateQuizTitle();
      setNightMode(state.settings.nightMode);
      render();
    }

    function syncSettingsControls() {
      document.getElementById("showExplanationsToggle").checked = !!state.settings.showExplanations;
      document.getElementById("shuffleOnResetToggle").checked = !!state.settings.shuffleOnReset;
      document.getElementById("compactModeToggle").checked = !!state.settings.compactMode;
      document.getElementById("shuffleOptionsToggle").checked = !!state.settings.shuffleOptions;
      document.getElementById("instantFeedbackToggle").checked = !!state.settings.instantFeedbackEnabled;
      document.getElementById("fancyButtonsToggle").checked = !!state.settings.fancyButtons;
      document.getElementById("nightModeToggle").checked = !!state.settings.nightMode;
      document.getElementById("titleInput").value = state.settings.titleText || "Choice Title.";
      document.getElementById("titleStyleSelect").value = state.settings.titleStyle || "classic";
    }

    function applyTitleStyle(styleKey) {
      const style = TITLE_STYLE_PRESETS[styleKey] || TITLE_STYLE_PRESETS.classic;
      const root = document.documentElement;
      root.style.setProperty("--accent", style.accent);
      root.style.setProperty("--accent-soft", `${style.accent}26`);
    }

    function getSavedQuizzes() {
      const saved = readStorageJson(STORAGE_KEYS.savedQuizzes);
      if (!saved || typeof saved !== "object") return {};
      return saved;
    }

    function updateSavedQuizSelect() {
      const select = document.getElementById("savedQuizSelect");
      if (!select) return;
      const saved = getSavedQuizzes();
      const titles = Object.keys(saved).sort((a, b) => a.localeCompare(b));
      select.innerHTML = "";
      const placeholder = document.createElement("option");
      placeholder.value = "";
      placeholder.textContent = titles.length ? "Select saved quiz" : "No saved quizzes";
      select.appendChild(placeholder);
      titles.forEach((title) => {
        const option = document.createElement("option");
        option.value = title;
        option.textContent = title;
        select.appendChild(option);
      });
      select.value = "";
    }

    function saveLoadedQuizSnapshot() {
      const titleInput = document.getElementById("saveQuizTitleInput");
      const title = clampText(titleInput?.value || "", 80);
      if (!title) {
        setStatus("Enter a saved quiz title first.", true);
        return;
      }

      const saved = getSavedQuizzes();
      saved[title] = {
        titleText: state.settings.titleText,
        titleStyle: state.settings.titleStyle,
        questionsBank,
        questionsHtmlInput: document.getElementById("questionsHtmlInput").value,
        savedAt: new Date().toISOString()
      };
      writeStorageJson(STORAGE_KEYS.savedQuizzes, saved);
      updateSavedQuizSelect();
      setStatus(`Saved "${title}" with ${questionsBank.length} question(s).`);
    }

    function loadSavedQuizSnapshot() {
      const select = document.getElementById("savedQuizSelect");
      const title = select.value;
      if (!title) {
        setStatus("Select a saved quiz to load.", true);
        return;
      }
      const saved = getSavedQuizzes();
      const snapshot = saved[title];
      if (!snapshot || !isValidQuestionBank(snapshot.questionsBank)) {
        setStatus("Saved quiz is invalid or missing.", true);
        return;
      }

      questionsBank = snapshot.questionsBank.map((q) => ({ ...q, choices: [...q.choices] }));
      state.settings.titleText = clampText(snapshot.titleText || state.settings.titleText, 120);
      state.settings.titleStyle = snapshot.titleStyle in TITLE_STYLE_PRESETS ? snapshot.titleStyle : "classic";
      document.getElementById("questionsHtmlInput").value = String(snapshot.questionsHtmlInput || "").slice(0, MAX_HTML_INPUT_LENGTH);
      writeStorageText(STORAGE_KEYS.questionsHtmlInput, document.getElementById("questionsHtmlInput").value);
      saveQuestionsBank();
      saveSettings();
      applyTitleStyle(state.settings.titleStyle);
      updateQuizTitle();
      initOrder();
      resetAll();
      syncSettingsControls();
      setStatus(`Loaded "${title}".`);
    }

    function deleteSavedQuizSnapshot() {
      const select = document.getElementById("savedQuizSelect");
      const title = select.value;
      if (!title) {
        setStatus("Select a saved quiz to delete.", true);
        return;
      }
      const saved = getSavedQuizzes();
      if (!saved[title]) {
        setStatus("Saved quiz was not found.", true);
        return;
      }
      delete saved[title];
      writeStorageJson(STORAGE_KEYS.savedQuizzes, saved);
      updateSavedQuizSelect();
      setStatus(`Deleted saved quiz "${title}".`);
    }

    function setStatus(message, isError = false) {
      const status = document.getElementById("htmlLoadStatus");
      status.textContent = message;
      status.classList.toggle("status-error", isError);
      status.classList.toggle("status-ok", !isError);
    }

    function setAnswerFixStatus(message, isError = false) {
      const status = document.getElementById("answerFixStatus");
      status.textContent = message;
      status.classList.toggle("status-error", isError);
      status.classList.toggle("status-ok", !isError);
    }

    function parseAnswerFixInput(raw) {
      const text = String(raw || "").trim();
      if (!text) {
        throw new Error("Enter a correction like: question 3 should be c");
      }
      if (text.length > MAX_ANSWER_FIX_INPUT_LENGTH) {
        throw new Error(`Correction is too long. Max ${MAX_ANSWER_FIX_INPUT_LENGTH} characters.`);
      }
      if (/[<>`]/.test(text)) {
        throw new Error("Invalid characters detected. Use plain text only.");
      }

      const qMatch = text.match(/question\s*(\d+)/i);
      if (!qMatch) {
        throw new Error("Could not find question number. Include 'question N'.");
      }

      let answerToken = null;
      const shouldBeMatch = text.match(/should\s*be\s*([a-z]|\d+)/i);
      if (shouldBeMatch) {
        answerToken = shouldBeMatch[1];
      } else {
        const tail = text.match(/\b([a-z]|\d+)\b\s*$/i);
        if (tail) answerToken = tail[1];
      }

      if (!answerToken) {
        throw new Error("Could not find corrected answer. Use a letter (A/B/C...) or index.");
      }

      return {
        questionNumber: Number(qMatch[1]),
        answerToken: answerToken.toLowerCase()
      };
    }

    function applyAnswerFixFromInput(raw) {
      const { questionNumber, answerToken } = parseAnswerFixInput(raw);
      if (!Number.isInteger(questionNumber) || questionNumber < 1 || questionNumber > state.order.length) {
        throw new Error(`Question number must be between 1 and ${state.order.length}.`);
      }

      const qid = state.order[questionNumber - 1];
      const item = questionsBank[qid];
      let answerIdx;

      if (/^\d+$/.test(answerToken)) {
        answerIdx = Number(answerToken);
      } else {
        answerIdx = answerToken.charCodeAt(0) - 97;
      }

      if (!Number.isInteger(answerIdx) || answerIdx < 0 || answerIdx >= item.choices.length) {
        throw new Error(`Answer must be within A-${String.fromCharCode(64 + item.choices.length)} for question ${questionNumber}.`);
      }

      const previousAnswer = item.answer;
      item.answer = answerIdx;

      if (state.locked[qid]) {
        const chosen = state.answers[qid];
        const wasCorrect = chosen === previousAnswer;
        const isCorrect = chosen === answerIdx;
        if (wasCorrect && !isCorrect) state.score = Math.max(0, state.score - 1);
        if (!wasCorrect && isCorrect) state.score += 1;
        showFeedback(qid);
        updateScoreUI();
      }

      const answerLetter = String.fromCharCode(65 + answerIdx);
      saveQuestionsBank();
      saveProgress();
      setAnswerFixStatus(`Updated question ${questionNumber} answer to ${answerLetter}. Existing answers were kept.`);
    }

    function clampText(text, maxLen = MAX_TEXT_LENGTH) {
      const clean = String(text || "").replace(/\s+/g, " ").trim();
      return clean.length > maxLen ? `${clean.slice(0, maxLen)}…` : clean;
    }

    function validateSafeHtmlTree(root) {
      const all = root.querySelectorAll("*");
      all.forEach((el) => {
        const tag = el.tagName.toLowerCase();
        if (FORBIDDEN_TAGS.has(tag)) {
          throw new Error(`Forbidden tag detected: <${tag}>`);
        }

        for (const attr of Array.from(el.attributes)) {
          const name = attr.name.toLowerCase();
          const value = attr.value.trim().toLowerCase();
          if (FORBIDDEN_ATTR_PREFIXES.some(prefix => name.startsWith(prefix))) {
            throw new Error(`Forbidden attribute detected: ${attr.name}`);
          }
          if (FORBIDDEN_ATTR_NAMES.has(name)) {
            throw new Error(`Forbidden attribute detected: ${attr.name}`);
          }
          if ((name === "href" || name === "src") && value.startsWith("javascript:")) {
            throw new Error(`Forbidden URL detected in ${attr.name}`);
          }
        }
      });
    }

    function parseHtmlInSandboxedDocument(html) {
      const parser = new DOMParser();
      const doc = parser.parseFromString(html, "text/html");
      validateSafeHtmlTree(doc.body);
      return doc.body;
    }

    function initOrder() {
      state.order = questionsBank.map((_, i) => i);
    }

    function normalizeHexColor(value, fallback) {
      if (typeof value !== "string") return fallback;
      const match = value.trim().match(/^#([0-9a-fA-F]{6})$/);
      return match ? `#${match[1].toLowerCase()}` : fallback;
    }

    function hexToRgb(hex) {
      const clean = normalizeHexColor(hex, "#ffffff").slice(1);
      return {
        r: parseInt(clean.slice(0, 2), 16),
        g: parseInt(clean.slice(2, 4), 16),
        b: parseInt(clean.slice(4, 6), 16)
      };
    }

    function adjustColor(hex, amount) {
      const { r, g, b } = hexToRgb(hex);
      const clamp = (n) => Math.max(0, Math.min(255, n));
      const toHex = (n) => clamp(n).toString(16).padStart(2, "0");
      return `#${toHex(r + amount)}${toHex(g + amount)}${toHex(b + amount)}`;
    }

    function applyThemeColors({ bg, surfaceTint }) {
      const root = document.documentElement;
      const fallbackTheme = state.settings.nightMode ? NIGHT_THEME : DEFAULT_THEME;
      const safeBg = normalizeHexColor(bg, fallbackTheme.bg);
      const safeTint = normalizeHexColor(surfaceTint, fallbackTheme.surfaceTint);

      root.style.setProperty("--bg", safeBg);
      root.style.setProperty("--surface", adjustColor(safeTint, 8));
      root.style.setProperty("--surface-soft", safeTint);
      root.style.setProperty("--button-bg", adjustColor(safeTint, -4));
      root.style.setProperty("--button-hover", adjustColor(safeTint, -14));
      root.style.setProperty("--text", state.settings.nightMode ? "#e5e7eb" : "#111");
      root.style.setProperty("--muted", state.settings.nightMode ? "#9ca3af" : "#666");
      root.style.setProperty("--border", state.settings.nightMode ? "#334155" : "#ddd");
    }

    function getThemeForMode(enabled) {
      return enabled ? state.settings.nightTheme : state.settings.dayTheme;
    }

    function setNightMode(enabled) {
      state.settings.nightMode = enabled;
      const theme = getThemeForMode(enabled);
      const bgInput = document.getElementById("bgColorInput");
      const tintInput = document.getElementById("surfaceTintInput");
      bgInput.value = theme.bg;
      tintInput.value = theme.surfaceTint;
      applyThemeColors(theme);
      saveSettings();
    }

    function updateThemeFromInputs() {
      const bgInput = document.getElementById("bgColorInput");
      const tintInput = document.getElementById("surfaceTintInput");
      const nextTheme = {
        bg: normalizeHexColor(bgInput.value, state.settings.nightMode ? NIGHT_THEME.bg : DEFAULT_THEME.bg),
        surfaceTint: normalizeHexColor(tintInput.value, state.settings.nightMode ? NIGHT_THEME.surfaceTint : DEFAULT_THEME.surfaceTint)
      };
      if (state.settings.nightMode) {
        state.settings.nightTheme = nextTheme;
      } else {
        state.settings.dayTheme = nextTheme;
      }
      applyThemeColors(nextTheme);
      saveSettings();
    }

    function shuffle(array) {
      for (let i = array.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]];
      }
    }

    function getChoiceOrder(qid, totalChoices) {
      if (!state.settings.shuffleOptions) {
        return Array.from({ length: totalChoices }, (_, i) => i);
      }

      if (!state.choiceOrder[qid] || state.choiceOrder[qid].length !== totalChoices) {
        const idx = Array.from({ length: totalChoices }, (_, i) => i);
        shuffle(idx);
        state.choiceOrder[qid] = idx;
      }

      return state.choiceOrder[qid];
    }

    function render() {
      const quiz = document.getElementById("quiz");
      quiz.innerHTML = "";

      const total = questionsBank.length;
      document.getElementById("total").textContent = total;
      document.getElementById("total2").textContent = total;

      state.order.forEach((qid, idx) => {
        const item = questionsBank[qid];
        const qDiv = document.createElement("div");
        qDiv.className = "q";
        qDiv.dataset.qid = qid;

        const head = document.createElement("div");
        head.className = "qhead";

        const left = document.createElement("div");
        const title = document.createElement("p");
        title.className = "qtitle";
        title.textContent = `Q${idx + 1}.`;
        left.appendChild(title);

        const tag = document.createElement("span");
        tag.className = "tag";
        tag.textContent = item.topic;

        head.appendChild(left);
        head.appendChild(tag);

        const prompt = document.createElement("div");
        prompt.className = "prompt";
        prompt.textContent = item.q;

        const opts = document.createElement("div");
        opts.className = "opts";

        const choiceOrder = getChoiceOrder(qid, item.choices.length);
        choiceOrder.forEach((originalChoiceIdx) => {
          const lab = document.createElement("label");
          lab.className = "opt";
          const radio = document.createElement("input");
          radio.type = "radio";
          radio.name = `q_${qid}`;
          radio.value = originalChoiceIdx;
          radio.disabled = !!state.locked[qid];

          if (state.answers[qid] === originalChoiceIdx) radio.checked = true;

          radio.addEventListener("change", () => onAnswer(qid, originalChoiceIdx));

          const span = document.createElement("span");
          span.textContent = item.choices[originalChoiceIdx];

          lab.appendChild(radio);
          lab.appendChild(span);
          opts.appendChild(lab);
        });

        const fb = document.createElement("div");
        fb.className = "feedback";
        fb.id = `fb_${qid}`;

        const actions = document.createElement("div");
        actions.className = "question-actions";

        const checkBtn = document.createElement("button");
        checkBtn.type = "button";
        checkBtn.className = "check-btn";
        checkBtn.id = `check_${qid}`;
        checkBtn.textContent = "Check Answer";
        checkBtn.style.display = state.settings.instantFeedbackEnabled ? "none" : "inline-block";
        checkBtn.disabled = !!state.locked[qid] || state.answers[qid] == null;
        checkBtn.addEventListener("click", () => onCheckAnswer(qid));
        actions.appendChild(checkBtn);

        const explain = document.createElement("div");
        explain.className = "explain";
        explain.id = `ex_${qid}`;

        qDiv.appendChild(head);
        qDiv.appendChild(prompt);
        qDiv.appendChild(opts);
        qDiv.appendChild(actions);
        qDiv.appendChild(fb);
        qDiv.appendChild(explain);

        quiz.appendChild(qDiv);
      });

      updateScoreUI();
      document.body.classList.toggle("compact", state.settings.compactMode);
      document.body.classList.toggle("fancy-ui", state.settings.fancyButtons);
      for (const qidStr of Object.keys(state.locked)) {
        showFeedback(Number(qidStr));
      }
    }

    function onAnswer(qid, choiceIdx) {
      if (state.locked[qid]) return;

      state.answers[qid] = choiceIdx;
      saveProgress();
      if (state.settings.instantFeedbackEnabled) {
        gradeAnswer(qid);
        return;
      }

      const checkBtn = document.getElementById(`check_${qid}`);
      if (checkBtn) checkBtn.disabled = false;
    }

    function onCheckAnswer(qid) {
      if (state.locked[qid]) return;
      if (state.answers[qid] == null) return;
      gradeAnswer(qid);
    }

    function gradeAnswer(qid) {
      const choiceIdx = state.answers[qid];
      if (choiceIdx == null || state.locked[qid]) return;

      state.locked[qid] = true;
      state.answered += 1;

      const correct = (choiceIdx === questionsBank[qid].answer);
      if (correct) state.score += 1;

      showFeedback(qid);
      updateScoreUI();
      document.querySelectorAll(`input[name="q_${qid}"]`).forEach(r => r.disabled = true);

      const checkBtn = document.getElementById(`check_${qid}`);
      if (checkBtn) checkBtn.disabled = true;
      saveProgress();
    }

    function showFeedback(qid) {
      const item = questionsBank[qid];
      const fb = document.getElementById(`fb_${qid}`);
      const ex = document.getElementById(`ex_${qid}`);
      const chosen = state.answers[qid];

      if (!state.settings.instantFeedbackEnabled && !state.locked[qid]) {
        fb.style.display = "none";
        ex.style.display = "none";
        ex.innerHTML = "";
        return;
      }

      const isCorrect = chosen === item.answer;
      fb.style.display = "block";
      fb.classList.remove("ok", "bad");
      fb.classList.add(isCorrect ? "ok" : "bad");

      const chosenText = (chosen != null) ? item.choices[chosen] : "—";
      const correctText = item.choices[item.answer];

      fb.textContent = isCorrect ? "✅ Correct" : "❌ Incorrect";
      if (state.settings.showExplanations) {
        ex.style.display = "block";
        ex.innerHTML = `
          <div><span class="muted">Your answer:</span> <strong>${escapeHtml(chosenText)}</strong></div>
          ${isCorrect ? "" : `<div><span class="muted">Correct answer:</span> <strong>${escapeHtml(correctText)}</strong></div>`}
          <div class="divider"></div>
          <div>${escapeHtml(item.explain || "")}</div>
        `;
      } else {
        ex.style.display = "none";
        ex.innerHTML = "";
      }
    }

    function updateScoreUI() {
      const total = questionsBank.length;
      document.getElementById("score").textContent = state.score;
      document.getElementById("answered").textContent = state.answered;
      const prog = document.getElementById("prog");
      prog.max = Math.max(total, 1);
      prog.value = state.answered;
    }

    function resetAll() {
      if (state.settings.shuffleOnReset) {
        initOrder();
        shuffle(state.order);
      }
      state.answers = {};
      state.locked = {};
      state.score = 0;
      state.answered = 0;
      state.choiceOrder = {};
      saveProgress();
      render();
      window.scrollTo({ top: 0, behavior: "smooth" });
    }

    function escapeHtml(s) {
      return String(s)
        .replaceAll("&", "&amp;")
        .replaceAll("<", "&lt;")
        .replaceAll(">", "&gt;")
        .replaceAll('"', "&quot;")
        .replaceAll("'", "&#039;");
    }


    function updateQuizTitle() {
      const baseTitle = clampText(state.settings.titleText || "Quiz", 120);
      const withSuffix = state.settings.instantFeedbackEnabled
        ? `${baseTitle} (Instant Feedback)`
        : baseTitle;

      document.getElementById("quizTitle").textContent = withSuffix;
      document.title = withSuffix;
      document.getElementById("instantFeedbackHint").style.display = state.settings.instantFeedbackEnabled ? "inline" : "none";
    }


    function refreshVisibleFeedback() {
      for (const qidStr of Object.keys(state.locked)) {
        showFeedback(Number(qidStr));
      }
    }

    function loadQuestionsFromHtml(html) {
      if (typeof html !== "string") {
        throw new Error("HTML input must be text.");
      }
      if (html.length === 0) {
        throw new Error("HTML input is empty.");
      }
      if (html.length > MAX_HTML_INPUT_LENGTH) {
        throw new Error(`HTML input is too large. Max ${MAX_HTML_INPUT_LENGTH} characters.`);
      }

      const safeRoot = parseHtmlInSandboxedDocument(html);
      const blocks = Array.from(safeRoot.querySelectorAll("[data-question]"));
      if (!blocks.length) {
        throw new Error("No question blocks found. Add elements with data-question attribute.");
      }
      if (blocks.length > MAX_QUESTIONS) {
        throw new Error(`Too many questions. Max ${MAX_QUESTIONS}.`);
      }

      const parsed = blocks.map((block, idx) => {
        const topic = clampText(block.getAttribute("data-topic") || "custom", 80);
        const answer = Number(block.getAttribute("data-answer"));
        const explain = clampText(block.getAttribute("data-explain") || "No explanation provided.");

        const qNode = block.querySelector("[data-q], h1, h2, h3, h4, p, div, span");
        const qText = clampText((qNode ? qNode.textContent : "") || `Question ${idx + 1}`);

        const choices = Array.from(block.querySelectorAll("li, [data-choice]"))
          .map(el => clampText(el.textContent || ""))
          .filter(Boolean);

        if (choices.length < 2) {
          throw new Error(`Question ${idx + 1} must have at least 2 choices.`);
        }
        if (choices.length > MAX_CHOICES_PER_QUESTION) {
          throw new Error(`Question ${idx + 1} has too many choices. Max ${MAX_CHOICES_PER_QUESTION}.`);
        }
        if (!Number.isInteger(answer) || answer < 0 || answer >= choices.length) {
          throw new Error(`Question ${idx + 1} has invalid data-answer index.`);
        }

        return { topic, q: qText, choices, answer, explain };
      });

      questionsBank = parsed;
      saveQuestionsBank();
      initOrder();
      resetAll();
    }

    document.getElementById("resetBtn").addEventListener("click", resetAll);
    document.getElementById("shuffleBtn").addEventListener("click", () => {
      initOrder();
      shuffle(state.order);
      resetAll();
    });

    const settingsBtn = document.getElementById("settingsBtn");
    const settingsPanel = document.getElementById("settingsPanel");
    settingsBtn.addEventListener("click", () => {
      settingsPanel.classList.toggle("open");
      const isOpen = settingsPanel.classList.contains("open");
      settingsBtn.setAttribute("aria-expanded", String(isOpen));
    });

    document.getElementById("showExplanationsToggle").addEventListener("change", (event) => {
      state.settings.showExplanations = event.target.checked;
      saveSettings();
      render();
    });

    document.getElementById("shuffleOnResetToggle").addEventListener("change", (event) => {
      state.settings.shuffleOnReset = event.target.checked;
      saveSettings();
    });

    document.getElementById("compactModeToggle").addEventListener("change", (event) => {
      state.settings.compactMode = event.target.checked;
      saveSettings();
      render();
    });

    document.getElementById("shuffleOptionsToggle").addEventListener("change", (event) => {
      state.settings.shuffleOptions = event.target.checked;
      saveSettings();
      state.choiceOrder = {};
      render();
    });

    const titleInput = document.getElementById("titleInput");
    titleInput.addEventListener("input", (event) => {
      state.settings.titleText = event.target.value;
      saveSettings();
      updateQuizTitle();
    });

    const titleStyleSelect = document.getElementById("titleStyleSelect");
    titleStyleSelect.addEventListener("change", (event) => {
      state.settings.titleStyle = event.target.value;
      applyTitleStyle(state.settings.titleStyle);
      saveSettings();
    });

    document.getElementById("instantFeedbackToggle").addEventListener("change", (event) => {
      state.settings.instantFeedbackEnabled = event.target.checked;
      saveSettings();
      updateQuizTitle();
      render();
    });

    document.getElementById("fancyButtonsToggle").addEventListener("change", (event) => {
      state.settings.fancyButtons = event.target.checked;
      saveSettings();
      render();
    });

    const toggleHtmlSectionBtn = document.getElementById("toggleHtmlSectionBtn");
    const loadQuestionsSection = document.getElementById("loadQuestionsSection");
    toggleHtmlSectionBtn.addEventListener("click", () => {
      const isHidden = loadQuestionsSection.style.display === "none";
      loadQuestionsSection.style.display = isHidden ? "block" : "none";
      toggleHtmlSectionBtn.textContent = isHidden ? "Hide Load Questions from HTML" : "Show Load Questions from HTML";
      toggleHtmlSectionBtn.setAttribute("aria-expanded", String(isHidden));
    });

    const bgColorInput = document.getElementById("bgColorInput");
    const surfaceTintInput = document.getElementById("surfaceTintInput");
    bgColorInput.addEventListener("input", updateThemeFromInputs);

    surfaceTintInput.addEventListener("input", updateThemeFromInputs);

    document.getElementById("nightModeToggle").addEventListener("change", (event) => {
      setNightMode(event.target.checked);
      saveSettings();
    });

    document.getElementById("resetColorsBtn").addEventListener("click", () => {
      const modeDefault = state.settings.nightMode ? NIGHT_THEME : DEFAULT_THEME;
      if (state.settings.nightMode) {
        state.settings.nightTheme = { ...modeDefault };
      } else {
        state.settings.dayTheme = { ...modeDefault };
      }
      bgColorInput.value = modeDefault.bg;
      surfaceTintInput.value = modeDefault.surfaceTint;
      applyThemeColors(modeDefault);
      saveSettings();
    });

    document.getElementById("restoreDefaultColorsBtn").addEventListener("click", () => {
      state.settings.dayTheme = { ...DEFAULT_THEME };
      state.settings.nightTheme = { ...NIGHT_THEME };
      state.settings.nightMode = false;
      document.getElementById("nightModeToggle").checked = false;
      bgColorInput.value = DEFAULT_THEME.bg;
      surfaceTintInput.value = DEFAULT_THEME.surfaceTint;
      applyThemeColors(DEFAULT_THEME);
      saveSettings();
    });

    document.getElementById("clearSavedDataBtn").addEventListener("click", clearSavedData);

    document.getElementById("questionsHtmlInput").addEventListener("input", (event) => {
      writeStorageText(STORAGE_KEYS.questionsHtmlInput, event.target.value.slice(0, MAX_HTML_INPUT_LENGTH));
    });

    document.getElementById("answerFixInput").addEventListener("input", (event) => {
      writeStorageText(STORAGE_KEYS.answerFixInput, event.target.value.slice(0, MAX_ANSWER_FIX_INPUT_LENGTH));
    });

    document.getElementById("loadQuestionsHtmlBtn").addEventListener("click", () => {
      const html = document.getElementById("questionsHtmlInput").value;
      try {
        loadQuestionsFromHtml(html);
        setStatus(`Loaded ${questionsBank.length} question(s).`);
      } catch (err) {
        setStatus(`Unable to load HTML: ${err.message}`, true);
      }
    });

    document.getElementById("saveLoadedQuizBtn").addEventListener("click", saveLoadedQuizSnapshot);
    document.getElementById("loadSavedQuizBtn").addEventListener("click", loadSavedQuizSnapshot);
    document.getElementById("deleteSavedQuizBtn").addEventListener("click", deleteSavedQuizSnapshot);

    document.getElementById("applyAnswerFixBtn").addEventListener("click", () => {
      const raw = document.getElementById("answerFixInput").value;
      writeStorageText(STORAGE_KEYS.answerFixInput, raw);
      try {
        applyAnswerFixFromInput(raw);
      } catch (err) {
        setAnswerFixStatus(`Unable to apply fix: ${err.message}`, true);
      }
    });

    const clipboardPromptPreview = document.getElementById("clipboardPromptPreview");
    const clipboardPrompt = `Convert my questions into the exact HTML format below.

Rules
- Output ONLY HTML
- Use this exact structure
- Keep all wording and option order exactly the same
- data-answer must be zero based index (first option = 0, second = 1, etc.)
- Support any number of options

Format

<article data-question data-topic="chem" data-answer="0" data-explain="Because...">
  <h3>Question text</h3>
  <ul>
    <li>Option 1</li>
    <li>Option 2</li>
    <li>Option 3</li>
  </ul>
</article>`;

    clipboardPromptPreview.value = clipboardPrompt;

    document.getElementById("copyPromptBtn").addEventListener("click", async () => {
      try {
        if (navigator.clipboard?.writeText) {
          await navigator.clipboard.writeText(clipboardPrompt);
        } else {
          const temp = document.createElement("textarea");
          temp.value = clipboardPrompt;
          document.body.appendChild(temp);
          temp.select();
          document.execCommand("copy");
          temp.remove();
        }
        setStatus("Prompt copied to clipboard.");
        clipboardPromptPreview.style.display = "none";
      } catch (err) {
        clipboardPromptPreview.style.display = "block";
        clipboardPromptPreview.focus();
        clipboardPromptPreview.select();
        setStatus("Select text for manual Ctrl+C in the settings.", true);
      }
    });

    hydrateFromStorage();
    syncSettingsControls();
    initOrder();
    hydrateProgressFromStorage();
    updateQuizTitle();
    applyTitleStyle(state.settings.titleStyle || "classic");
    updateSavedQuizSelect();
    setNightMode(state.settings.nightMode);
    render();
  </script>
</body>
</html>
